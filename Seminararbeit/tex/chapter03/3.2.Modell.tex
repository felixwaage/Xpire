% !TEX root =  master.tex
\newpage
\section{Konzeptuelles Modell}
% Welche Architektur und Warum?
% User-Authentifizierung?
% Welche Persistierung?
% Welche Tests und warum?

In den vorherigen Abschnitten wurden bereits einige Merkmale der Xpire-App beschrieben. Darauf aufbauend sollen im Folgenden die Zusammenhänge der verschiedenen Bestandteile näher erläutert werden und somit einen detaillierten Überblick über das konzeptionelle Modell liefern.\\
Kern der Xpire-App ist das Frontend, welches mit Hilfe von React als PWA konzipiert ist. Wie den Abbildungen \ref{fig:prot1} und \ref{fig:prot2} entnommen werden kann, besteht die Xpire-App aus 3 Ansichten: \textit{Home-Screen}, \textit{Product-Screen} und dem \textit{Create-Screen}. Diese Ansichten werden in React durch Komponenten realisiert, welche in unterschiedlichen Kontexten wiederverwendet werden können. Der Home-Screen besitzt demzufolge die Komponente AppBar und eine Komponente zur Listendarstellung der Produkte. Die Ansichten \textit{Product-Screen} und \textit{Create-Screen} werden durch dieselbe Komponente realisiert, da zum Erstellen und Anzeigen der Produktinformation ähnliche UI-Bestandteile benötigt werden. Die Darstellung passt sich hierbei automatisch anhand der übergebenen Parameter an. Hierdurch können Code-Duplikate vermieden werden und auch der Raum für Fehler wird reduziert.\\
Ein Weiterer wichtiger Bestandteil der Anwendung ist die IndexedDB, welche zur dauerhaften Persistierung der Daten verwendet wird. Wie bereits in Abschnitt \ref{chapter:datenbank} erwähnt wird hierfür das Modul \textit{Dexie} verwendet. Neben der Datenhaltung in der lokalen Datenbank wird eine aktuelle Kopie der gesamten Datenbank in einem Array im \textit{State} der App-Komponente synchron gehalten, wodurch sowohl die Listen-Komponente als auch die Product-Screen-Komponente darauf zugreifen können.

Der Nutzer soll später seine Produkte mit Hilfe des einheitlichen Barcodes hinzufügen können. Dies soll die Verwendung deutlich beschleunigen und vereinfachen, da so Informationen wie Titel, Gewicht, usw. nicht manuell eingetragen werden müssen. Um die dazu benötigten Informationen zu erhalten, wird die OpenFoodFacts-Api verwendet. Diese führt eine Datenbank mit umfassenden Produktinformationen und kann Anfragen über den Barcode entgegennehmen. Des Weiteren wird diese API verwendet, um Abbildungen der einzelnen Produkte zu erhalten. Dadurch wird dem Nutzer die Verwendung der Anwendung zusätzlich vereinfacht. Darüber hinaus ist in einer späteren Version angedacht, die Produktbilder lokal in der Datenbank zu speichern, um auch bei Offline-Betrieb die Bilder anzeigen zu können.

\subsection{Notifications}
Damit der Nutzer der App diese nicht aktiv öffnen muss, um über demnächst ablaufende Produkte informiert zu werden, ist es sehr sinnvoll, dass die App automatisch Push-Mitteilungen versendet. Moderne Browser können heutzutage solche Benachrichtigungen von Webseiten anzeigen, die hierfür die Notifications-API\footnote{\url{https://developer.mozilla.org/en-US/docs/Web/API/Notifications_API}} nutzen. 
Normalerweise werden solche Push-Nachrichten von einem Server der Webseite ausgelöst. Da unsere Anwendung aber komplett dezentral ausgeführt werden soll, muss eine Möglichkeit gefunden werden, die Notifications on-Device zu triggern. Es genügt nämlich nicht, bei bestimmten Interaktionen über die angebundenen Event-Handler eine Mitteilung auszulösen, sie müssen vielmehr terminiert werden können.\\
Hierzu gibt es im aktuellen Web-Standard keine vorgesehene Funktion, jedoch testet Google ganz aktuell dahingehend eine Erweiterung der Notifications-API.\footnote{\url{https://developers.chrome.com/origintrials/#/view_trial/6883752030435803137}}
Im Rahmen eines sogenannten Origin Trials wird ein sicheres Experimentieren mit neuen Funktionen der Web-Plattform ermöglicht. Um die bestmöglichen Designs zu erzielen, werden solche neuen Funktionen nicht vorzeitig zu De-facto-Standards, auf die sich Webentwickler dann verlassen und eine Abänderung nur schwer möglich machen, sondern sie werden in einem iterativen Prozess getestet und durch Feedback verbessert, bevor sie letztendlich in den Standard ausgerollt werden.
So sollte es im Idealfall einfacher sein, neue Funktionen freizulegen und zu iterieren, aber die Versuchspopulation zuverlässig einzuschränken. Mit einer Testpopulation von Entwicklern, die sich verpflichtet haben, Feedback zu geben, und Begrenzungen in der Größe der Anwenderbasis und der Versuchsdauer kann die Iteration schneller erfolgen, aber ohne das Risiko eines sogenannten Burn-in, also einer Resistenz gegen Veränderungen.
Nun haben wir also ein zeitlich begrenztes Token von Google angefordert, um die Funktion \emph{Notification Triggers}\footnote{\url{https://github.com/rknoll/notification-triggers}} für unsere Webapp freizuschalten. Dieses wird im \texttt{<head>}-Tag der \ac{HTML}-Seite mitgegeben. Zusätzlich muss, da wir React verwenden, dem Compiler per ESLint-Befehl mitgeteilt werden, dass Undef-Fehler für die verwendete Klasse \texttt{TimestampTrigger} ignoriert werden sollen, schließlich ist sie noch nicht Teil des Standards, wird aber von Chrome 80+ entsprechend erkannt. Mit dieser Beta-Funktion ist es dann möglich, einen Zeitstempel für das Feuern einer Mitteilung festzulegen und im Service-Worker zu registrieren.\footnote{\url{https://web.dev/notification-triggers/}} Somit ist es uns gelungen, für jedes Produkt einen Alarm zu setzen, der rechtzeitig vor Verfall den User per Push-Mitteilung informiert.